屏幕边缘碰撞
```js
'use strict';

export var scriptProperties = createScriptProperties()
    .addSlider({
        name: 'movSpeed',
        label: 'Movement Speed',
        value: 100,
        min: 1,
        max: 1000,
        integer: true
    })
    .finish();

import * as WEVector from 'WEVector';

// Choose a random direction in 360 degree range
var direction = new Vec3(WEVector.angleVector2(Math.random() * 360));

/**
 * @param {Vec3} value - for property 'origin'
 * @return {Vec3} - updated origin value
 */
export function update(value) {
    let scale = thisLayer.scale;
    let imageSize = thisLayer.size;
    let canvasSize = engine.canvasSize;

    // We need the size from the center to the bounds.
    imageSize.x *= scale.x * 0.5;
    imageSize.y *= scale.y * 0.5;

    // Move along the direction.
    value = value.add(direction.multiply(engine.frametime * scriptProperties.movSpeed));

    // Hit the screen bounds and reflect the direction.
    if (value.x < imageSize.x) {
        value.x = imageSize.x;
        direction = direction.reflect(new Vec3(1, 0));
    } else if (value.x > canvasSize.x - imageSize.x) {
        value.x = canvasSize.x - imageSize.x;
        direction = direction.reflect(new Vec3(-1, 0));
    }

    if (value.y < imageSize.y) {
        value.y = imageSize.y;
        direction = direction.reflect(new Vec3(0, 1));
    } else if (value.y > canvasSize.y - imageSize.y) {
        value.y = canvasSize.y - imageSize.y;
        direction = direction.reflect(new Vec3(0, -1));
    }

    return value;
}
```

固定距离碰撞
```js
'use strict';

import * as WEVector from 'WEVector';

export var scriptProperties = createScriptProperties()
    .addSlider({
        name: 'radius',
        label: 'Movement Radius',
        value: 100,
        min: 10,
        max: 500,
        integer: false
    })
    .addSlider({
        name: 'speed',
        label: 'Movement Speed',
        value: 50,
        min: 10,
        max: 200,
        integer: false
    })
    .finish();

let targetPosition;
let initialPosition;
let moving = false;

/**
 * @param {Vec3} value - for property 'origin'
 * @return {Vec3} - update current property value
 */
export function init(value) {
    initialPosition = value;
    targetPosition = value;
    return value;
}

export function update(value) {
    if (!moving || value == targetPosition) {
        // Generate a random target position within the specified radius from the initial position
        let angle = Math.random() * 2 * Math.PI;
        let distance = Math.random() * scriptProperties.radius;
        targetPosition = new Vec3(
            initialPosition.x + Math.cos(angle) * distance,
            initialPosition.y + Math.sin(angle) * distance,
            initialPosition.z
        );
        moving = true;
    }

    // Calculate the direction vector towards the target position
    let direction = targetPosition.subtract(value);
    let distanceToTarget = direction.length();
    direction = direction.normalize();

    // Calculate the new position
    let step = direction.multiply(scriptProperties.speed * engine.frametime);
    if (distanceToTarget < step.length()) {
        value = targetPosition;
        moving = false;
    } else {
        value = value.add(step);
    }

    return value;
}
```