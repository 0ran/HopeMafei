```js
'use strict';

import * as WEVector from 'WEVector';

/**
 * 合并的脚本：既支持屏幕弹跳又支持鼠标拖拽，带有推力效果
 * 将此脚本绑定到图层的 'origin' 属性
 */

// 拖拽相关变量
let isDragging = false;
let dragOffset;
let lastMousePosition = new Vec3(0, 0, 0);
let currentMousePosition = new Vec3(0, 0, 0);
let mouseVelocity = new Vec3(0, 0, 0);
let lastUpdateTime = 0;

// 弹跳相关变量
let bounceSpeed = 1000;
let direction = new Vec3(WEVector.angleVector2(45 + Math.floor(Math.random() * 4) * 90));

/**
 * 鼠标按下事件
 * @param {CursorEvent} event
 */
export function cursorDown(event) {
    isDragging = true;
    dragOffset = thisLayer.origin.subtract(event.worldPosition);
    
    // 重置鼠标位置跟踪
    lastMousePosition = new Vec3(event.worldPosition.x, event.worldPosition.y, event.worldPosition.z);
    currentMousePosition = new Vec3(event.worldPosition.x, event.worldPosition.y, event.worldPosition.z);
    mouseVelocity = new Vec3(0, 0, 0);
    lastUpdateTime = Date.now() / 1000; // 转换为秒
}

/**
 * 鼠标释放事件
 * @param {CursorEvent} event
 */
export function cursorUp(event) {
    isDragging = false;
    
    // 计算推力系数 - 限制最大推力
    const maxSpeed = 1000;
    const speedFactor = 10; // 推力倍数
    
    // 使用鼠标速度作为推力方向和大小
    let pushForce = mouseVelocity.multiply(speedFactor);
    
    // 限制最大推力
    let magnitude = pushForce.length();
    if (magnitude > maxSpeed) {
        pushForce = pushForce.multiply(maxSpeed / magnitude);
    }
    
    // 将推力应用到弹跳方向
    direction = pushForce.normalize();
    
    // 根据推力大小调整弹跳速度
    bounceSpeed = 1000 + pushForce.length() * 0.5;
    
    // 如果推力太小，使用随机方向
    if (pushForce.length() < 50) {
        direction = new Vec3(WEVector.angleVector2(45 + Math.floor(Math.random() * 4) * 90));
        bounceSpeed = 100;
    }
}


export function cursorMove(event) {
    if (isDragging) {
        // 更新当前鼠标位置
        currentMousePosition = new Vec3(event.worldPosition.x, event.worldPosition.y, event.worldPosition.z);
        
        // 计算时间差
        const currentTime = Date.now() / 1000; // 转换为秒
        const deltaTime = currentTime - lastUpdateTime;
        
        if (deltaTime > 0) {
            // 计算鼠标速度向量 (像素/秒)
            const displacement = currentMousePosition.subtract(lastMousePosition);
            mouseVelocity = displacement.multiply(1 / deltaTime);
            
            // 更新上一次位置和时间
            lastMousePosition = new Vec3(currentMousePosition.x, currentMousePosition.y, currentMousePosition.z);
            lastUpdateTime = currentTime;
        }
        
        // 更新图层位置
        thisLayer.origin = event.worldPosition.add(dragOffset);
    }
}


export function update(value) {
    // 如果正在拖拽，不执行弹跳逻辑
    if (isDragging) {
        return value;
    }

    let scale = thisLayer.scale;
    let imageSize = thisLayer.size;
    let canvasSize = engine.canvasSize;

    // 计算从中心到边界的尺寸
    imageSize.x *= scale.x * 0.5;
    imageSize.y *= scale.y * 0.5;

    // 沿方向移动
    value = value.add(direction.multiply(engine.frametime * bounceSpeed));

    // 碰撞检测和方向反射
    if (value.x < imageSize.x) {
        value.x = imageSize.x;
        direction = direction.reflect(new Vec3(1, 0));
    } else if (value.x > canvasSize.x - imageSize.x) {
        value.x = canvasSize.x - imageSize.x;
        direction = direction.reflect(new Vec3(-1, 0));
    }

    if (value.y < imageSize.y) {
        value.y = imageSize.y;
        direction = direction.reflect(new Vec3(0, 1));
    } else if (value.y > canvasSize.y - imageSize.y) {
        value.y = canvasSize.y - imageSize.y;
        direction = direction.reflect(new Vec3(0, -1));
    }

    return value;
}
```